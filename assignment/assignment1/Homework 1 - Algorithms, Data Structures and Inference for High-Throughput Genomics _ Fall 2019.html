<!DOCTYPE html>
<!-- saved from url=(0058)https://rob-p.github.io/CMSC858D/assignments/02_homework_1 -->
<html class="gr__rob-p_github_io"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics / Fall 2019 </title>
  <meta name="description" content="CMSC858D Homework 1 : Implementing some succinct primitivesThis homework consists of 3 programming tasks.  The programming tasks build upon each other, and s...">
  
  <link rel="stylesheet" href="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/main.css">
  <link rel="canonical" href="https://rob-p.github.io/CMSC858D/CMSC858D/assignments/02_homework_1">
  <link rel="alternate" type="application/rss+xml" title="University of Maryland" href="https://rob-p.github.io/CMSC858D/CMSC858D/feed.xml">
<link rel="stylesheet" id="open-sans-css" href="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/css" type="text/css" media="all">
<link href="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/css(1)" rel="stylesheet" type="text/css">





<link rel="stylesheet" href="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
</head>


  <body data-gr-c-s-loaded="true"><div id="StayFocusd-infobar" style="display: none; top: 0px;">
    <img src="chrome-extension://laankejkbhbdhmipfmgcngdelahlfoji/common/img/eye_19x19_red.png">
    <span id="StayFocusd-infobar-msg"></span>
    <span id="StayFocusd-infobar-links">
        <a id="StayFocusd-infobar-never-show">hide forever</a>&nbsp;&nbsp;|&nbsp;&nbsp;
        <a id="StayFocusd-infobar-hide">hide once</a>
    </span>
</div>

    <header class="site-header">

  <div class="wrapper">
      <table><tbody><tr>
          <td><img width="75" src="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/28_informalseal.jpg" valign="middle"></td>
          <td style="padding-left:10px;"><a style="font-size: 15px;color: #ffffffc7;" class="site-title" href="http://www.iust.ac.ir/">University of Maryland</a>
          <br>
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="https://rob-p.github.io/CMSC858D/" title="Algorithms, Data Structures and Inference for High-Throughput Genomics / Fall 2019 - University of Maryland"><b>Algorithms, Data Structures and Inference for High-Throughput Genomics</b></a></span>
          <br>
          <span style="color: #ffffffb3;font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Fall 2019</span>
          </td>
        </tr></tbody></table>

    <nav class="site-nav">

      <a href="https://rob-p.github.io/CMSC858D/assignments/02_homework_1#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1>

 <ul class="menu">
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/"><i class="fa fa-home fa-lg"></i> Home</a></li>
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/schedule/"><i class="fas fa-calendar-alt"></i> Schedule</a></li>
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/lectures/"><i class="fas fa-book-reader"></i> Lectures</a></li>
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/assignments/"><i class="fas fa-user-graduate"></i> Assignments</a></li>
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/final_project/"><i class="fas fa-user-graduate"></i> Final Project</a></li>
    <li><a class="page-link" href="https://rob-p.github.io/CMSC858D/course-materials/"><i class="fas fa-book"></i> Course Materials</a></li>
</ul>

     </div>  
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Homework 1</h1>
    <p class="post-meta">Released on Monday 2019-10-14 00:00:00 +0000</p>
  </header>

  <div>
    
    <span style="font-weight: bold">Due Date: 2019-10-29 00:00</span>
    
    <p style="font-weight: bold">Download
      
      
      
    </p>

    <!--<div style="color: gray;">
      <h3>Late Policy</h3>
      <ul>
    
    <li>You have free 8 late days.</li>
    
    <li>You can use late days for assignments. A late day extends the deadline 24 hours.</li>
    
    <li>Once you have used all 8 late days, the penalty is 10% for each additional late day.</li>
    
</ul>
    </div>-->
  </div>

  <br>
  <article class="post-content">
    <h1 id="cmsc858d-homework-1--implementing-some-succinct-primitives">CMSC858D Homework 1 : Implementing some succinct primitives</h1>

<p>This homework consists of 3 programming tasks.  The programming tasks build upon each other, and so should be implemented in order.  Each programming tasks consists of (1) an implementation and (2) a writeup.  Each implementation should be done in a separate directory, along with a README containing instructions for building (if necessary) and using the implementation (e.g. a description of the library interface, and the command-line interace if it exists).  In addition to the code you submit directly, you should also make a GitHub repository to which you post the code, and you should link to this in the README.</p>

<p>The writeups for all three tasks should be put into a single document (either a PDF or a Word Document).  Each writeup should include the following <strong>3</strong> components:</p>

<ol>
  <li>
    <p>A short (no more than a paragraph) prose description of your implementation.</p>
  </li>
  <li>
    <p>A brief (again, no more than a paragraph) summary of what you found to be the most difficult part of implementing each task.</p>
  </li>
  <li>
    <p>The plots as described in each task.</p>
  </li>
</ol>

<h2 id="programming-tasks">Programming Tasks</h2>

<p><strong>Note</strong> : For the programming tasks of this assignment, you are allowed to use any “reasonable” language of your preference. Here, “reasonable” means free / open (e.g. no MATLAB), and not overly esoteric (e.g. don’t write your implementation in <a href="https://en.wikipedia.org/wiki/Esoteric_programming_language#Whitespace">whitespace</a>).  If you are not sure if a language counts as too “esoteric”, just ask me. I’ll note that some of the code for this assignment may likely be <em>easier</em> to write in a “lower-level” language that gives you direct access to bit-manipulation primitives.  You may <em>not</em> use a succinct data structure library to implement these tasks (the point is for you to implement them yourself).  However, you <em>may</em> choose to use a library to provide the basic bit-vector representation and direct access operations if you wish (i.e. you may use the library to allow creation, population and direct access to a bit-vector, but not for rank, select, or any other “higher-level” operations).</p>

<p>If you end up deriving some piece of your code from a source you encounter (either code, or a paper), make sure to <em>cite</em> this source in both your code and in the homework you turn in.</p>

<h2 id="task-1--bit-vector-rank">Task 1 — bit-vector rank</h2>

<p>Implement a succinct, constant-time, bit-vector rank operation.  The exact design of the implementation is up to you, but the following requirements are put in place.  In addition to turning your code in on ELMS, you should upload your code to a GitHub repository and include the link in your submission.</p>

<ul>
  <li>
    <p>Your rank support should be a class / structure that “wraps” the underlying bit-vector.  In C++ lingo, something like:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bit_vector b;
 // do some stuff with b
 rank_support r(&amp;b); // let r access b via a pointer
 auto x = r(i); // x now holds the value of rank1(b, i);
                // I'm using r(i) (operator()) as a shorthand
                // for rank1(.) as defined below.
</code></pre></div>    </div>
  </li>
  <li>
    <p>You should implement the following methods for your rank_support class (type signatures are given for C++, use your judgement if implementing in another language):</p>

    <ul>
      <li><code class="highlighter-rouge">uint64_t rank1(uint64_t i)</code> : Returns the number of 1s in the underlying bit-vector up to position i (inclusive).</li>
      <li><code class="highlighter-rouge">uint64_t rank0(uint64_t i)</code> : Returns the number of 0s in the underlying bit-vector up to position i (inclusive) — simply <code class="highlighter-rouge">i - rank1(i)</code>.</li>
      <li><code class="highlighter-rouge">uint64_t overhead()</code> : Returns the size of the rank data structure (in <em>bits</em>) that is required to support constant-time rank on the current bitvector.</li>
    </ul>
  </li>
</ul>

<p><strong>Writeup</strong>: For this programming task, test your implementation by invoking it for bit vectors of various sizes, and plotting the bit-vector size (say N) versus the time requried to do some fixed number of rank operations.  Also, plot the bit-vector size (say N) versus the result of calling the <code class="highlighter-rouge">overhead()</code> function.  Does your implementation match the expected theoretical bounds?</p>

<h2 id="task-2--bit-vector-select">Task 2 — bit-vector select</h2>

<p>Implement a succinct, log-time, bit-vector select operation.  The exact design of the implementation is up to you, but the following requirements are put in place.  In addition to turning your code in on ELMS, you should upload your code to a GitHub repository and include the link in your submission.</p>

<ul>
  <li>
    <p>Your select support should be a class / structure that “wraps” the underlying bit-vector.  In C++ lingo, something like:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bit_vector b;
 // do some stuff with b
 rank_support r(&amp;b); // let r access b via a pointer
 select_support s(&amp;r); // let s access r via a pointer
 auto x = s(i); // x now holds the value of select1(b, i);
                // I'm using r(i) (operator()) as a shorthand
                // for select1(.) as defined below.
</code></pre></div>    </div>
  </li>
  <li>
    <p>You should implement the following methods for your rank_support class (type signatures are given for C++, use your judgement if implementing in another language):</p>

    <ul>
      <li><code class="highlighter-rouge">uint64_t select1(uint64_t i)</code> : Returns the position, in the underlying bit-vector, of the i<sup>th</sup> 1.</li>
      <li><code class="highlighter-rouge">uint64_t rank0(uint64_t i)</code> : Returns the the position, in the underlying bit-vector, of the i<sup>th</sup> 0.</li>
      <li><code class="highlighter-rouge">uint64_t overhead()</code> : Returns the size of the select data structure (in <em>bits</em>) that is required to support log-time select on the current bitvector (how does this relate to the size of the <code class="highlighter-rouge">rank</code> data structure built above).</li>
    </ul>
  </li>
</ul>

<p><strong>Writeup</strong>: For this programming task, test your implementation by invoking it for bit vectors of various sizes, and plotting the bit-vector size (say N) versus the time requried to do some fixed number of select operations.  Also, plot the bit-vector size (say N) versus the result of calling the <code class="highlighter-rouge">overhead()</code> function.  Does your implementation match the expected theoretical bounds?  <em>If you feel ambitious</em>, you can additionally implement a constant-time bit-vector select, though this is not required.</p>

<p>## Task 3 — wavelet tree construction and query.</p>

<p>Implement wavelet tree construction, serialization, and the operations <code class="highlighter-rouge">access(i)</code>, <code class="highlighter-rouge">rank(c, i)</code>, and <code class="highlighter-rouge">select(c, i)</code>. You can use any wavelet tree construction algorithm you wish.  I suggest looking <a href="https://epubs.siam.org/doi/pdf/10.1137/1.9781611975055.2">here</a> for some simple yet efficient algorithms for wavelet tree construction.</p>

<p>Your final implementation should be a <strong>command-line</strong> program with the following interace (below, <code class="highlighter-rouge">$</code> is the command-line prompt and the name of the program is <code class="highlighter-rouge">wt</code>).</p>

<ul>
  <li>
    <p>Build a wavelet tree from a string containing an input text.  This command reads the string in <code class="highlighter-rouge">&lt;input file&gt;</code>, constructs the wavelet tree, and saves the resulting structure to the file <code class="highlighter-rouge">&lt;output file&gt;</code>.  The program should also write two lines to standard out; the first line should contain the number of distinct input characters in the <code class="highlighter-rouge">&lt;input string&gt;</code> file (i.e. the size of the alphabet of the string the tree is constructed over) and the second line should contain the number of characters in the input string.  The command should be executed as follows:</p>

    <p><code class="highlighter-rouge">$wt build &lt;input string&gt; &lt;output file&gt;</code></p>
  </li>
  <li>
    <p>Load a wavelet tree from file, and issue a series of <code class="highlighter-rouge">access</code> queries on the indices contained in another file.  Below, <code class="highlighter-rouge">&lt;saved wt&gt;</code> is the file saved as <code class="highlighter-rouge">&lt;output file&gt;</code> above, and <code class="highlighter-rouge">&lt;access indices&gt;</code> is a file containing a newline-separated list of indices (0-based) to access. The program should output the characters (one per-line) corresponding to each index in the file <code class="highlighter-rouge">&lt;access indices&gt;</code> to standard out:</p>

    <p><code class="highlighter-rouge">$wt access &lt;saved wt&gt; &lt;access indices&gt;</code></p>
  </li>
  <li>
    <p>Load a wavelet tree from file and issue a series of rank queries on the contents of another file. Below, <code class="highlighter-rouge">&lt;saved wt&gt;</code> is the file saved as <code class="highlighter-rouge">&lt;output file&gt;</code> from the construction command above, and <code class="highlighter-rouge">&lt;rank queries&gt;</code> is a file containing a newline-separated list of rank queries to issue.  Each rank query is of the format <code class="highlighter-rouge">&lt;c&gt;\t&lt;i&gt;</code>, where <code class="highlighter-rouge">&lt;c&gt;</code> is some character from the alphabet of the original string, <code class="highlighter-rouge">&lt;i&gt;</code> is some index and <code class="highlighter-rouge">\t</code> is the tab character.  The program should output the answers to the rank queries (one per-line) corresponding to each query in the file <code class="highlighter-rouge">&lt;rank queries&gt;</code> to standard out:</p>

    <p><code class="highlighter-rouge">$wt rank &lt;saved wt&gt; &lt;access indices&gt;</code></p>
  </li>
  <li>
    <p>Load a wavelet tree from file and issue a series of rank queries on the contents of another file. Below, <code class="highlighter-rouge">&lt;saved wt&gt;</code> is the file saved as <code class="highlighter-rouge">&lt;output file&gt;</code> from the construction command above, and <code class="highlighter-rouge">&lt;select queries&gt;</code> is a file containing a newline-separated list of select queries to issue.  Each select query is of the format <code class="highlighter-rouge">&lt;c&gt;\t&lt;i&gt;</code>, where <code class="highlighter-rouge">&lt;c&gt;</code> is some character from the alphabet of the original string, <code class="highlighter-rouge">&lt;i&gt;</code> is the occurrence of the character <code class="highlighter-rouge">&lt;c&gt;</code> for one wishes to know the index (again, <code class="highlighter-rouge">\t</code> is the tab character).  The program should output the answers to the select queries (one per-line) corresponding to each query in the file <code class="highlighter-rouge">&lt;select queries&gt;</code> to standard out:</p>

    <p><code class="highlighter-rouge">$wt select &lt;saved wt&gt; &lt;access indices&gt;</code></p>
  </li>
</ul>

<p><strong>Writeup</strong>: For this programming task, test your implementation by invoking it for some input strings of various sizes and with various numbers of distinct characters in the input string.  Try plotting how (1) the rank and select queries in the wavelet tree scale as a factor of the string length and (2) how, at a fixed string length, how the rank and select queries scale as a factor of the number of distinct characters in the input string.  How do your plots compare to expectation? <em>Note</em>: for the purpose of making these plots, you need not use the command-line interace described above.  You can avoid the overhead by constructing the wavelet tree from the input, and then issuing the rank and select queries directly via function calls without serializing the tree to disk first.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

<!--     <h2 class="footer-heading">University of Maryland</h2> -->
         <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
 
          <ul class="contact-list">
          <li><strong>University of Maryland</strong></li>
			<li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
 

         <p class="text">
Department of Computer Science<br>
University of Maryland<br>
College Park, MD<br>

      </p></div>

      <div class="footer-col  footer-col-3">
       <ul class="social-media-list">
     

          

          

          

          

          



       
        </ul>
      </div>
    </div>

  </div>

</footer>

  


<!-- d.s.m.s.050600.062508.030515.080516.030818 | "Baby, I'm Yours" --><gdiv class="ginger-extension-writer" style="display: none;"><gdiv class="ginger-extension-writer-frame"><iframe src="./Homework 1 - Algorithms, Data Structures and Inference for High-Throughput Genomics _ Fall 2019_files/index.html"></iframe></gdiv></gdiv></body></html>